


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > Model</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">main.java.model</a>
</div>

<h1>Coverage Summary for Class: Model (main.java.model)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Model</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (28/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.7%
  </span>
  <span class="absValue">
    (244/272)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Model$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$3kkqdqT5</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$5Hi8RGVM</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$6it73kYi</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$aOPqAKzm</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$cdQ8lnZg</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$HauAICNU</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$MM3zFq7s</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$q5HRTdb9</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$R2DHZ4zK</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$RI6IPRqU</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$T0nKjVpl</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$T5A311Ag</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$TWSxtyoy</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$VmQEPqpr</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$vxUIrupa</td>
  </tr>
  <tr>
    <td class="name">Model$MockitoMock$B1ufh9oL$auxiliary$wdg7kF0j</td>
  </tr>
  <tr>
    <td class="name">Model$Scales</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (30/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.8%
  </span>
  <span class="absValue">
    (247/275)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package main.java.model;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.time.DayOfWeek;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.Period;
&nbsp;import java.time.format.DateTimeFormatter;
&nbsp;import java.time.temporal.TemporalAdjusters;
&nbsp;import java.time.temporal.WeekFields;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Locale;
&nbsp;import java.util.Map;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.TreeSet;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;import java.util.stream.Stream;
&nbsp;
&nbsp;import main.java.model.entities.GraphResponseWrapper;
&nbsp;import main.java.model.entities.PurchasedStock;
&nbsp;import main.java.model.entities.Stock;
&nbsp;import main.java.model.entities.StockPriceResponseWrapper;
&nbsp;import main.java.model.entities.StockTransaction;
&nbsp;import main.java.model.entities.StockWeight;
&nbsp;import main.java.model.entities.Strategy;
&nbsp;import main.java.model.util.Util;
&nbsp;
&nbsp;import static java.time.temporal.ChronoUnit.DAYS;
&nbsp;import static java.time.temporal.TemporalAdjusters.lastDayOfMonth;
&nbsp;
&nbsp;/**
&nbsp; * This class represents implementation of the IModel interface. Some of the data that is required
&nbsp; * by this model(prices of stocks,supported stock list,persisted portfolios) is dependent on the
&nbsp; * DataIO and the PriceProvider object that is passed to the model constructor.
&nbsp; */
&nbsp;public class Model implements IModel {
&nbsp;
&nbsp;  private static List&lt;Stock&gt; stockMasterList;
<b class="fc">&nbsp;  final DayOfWeek firstDayOfWeek = WeekFields.of(Locale.US).getFirstDayOfWeek();</b>
<b class="fc">&nbsp;  final DayOfWeek lastDayOfWeek =</b>
<b class="fc">&nbsp;          DayOfWeek.of(((firstDayOfWeek.getValue() + 5) % DayOfWeek.values().length) + 1);</b>
&nbsp;  Util.TransactionType transactionTypes;
&nbsp;  private DataIO dataIO;
&nbsp;  private List&lt;Portfolio&gt; portfolioList;
&nbsp;
&nbsp;  //by default the commission for the system would be 5$ if not updated by the user
<b class="fc">&nbsp;  private Double commission = 5d;</b>
&nbsp;  private PriceProvider priceProvider;
&nbsp;
&nbsp;  /**
&nbsp;   * Constructs a Model object which can be used by the controller. The data for the model is
&nbsp;   * updated from the DataIO and PriceProvider object passed to it.
&nbsp;   *
&nbsp;   * @param dataIO DataIo object which needs to be used to get the data in the model
&nbsp;   * @param priceProvider PriceProvider object which needs to be used to get prices of the
&nbsp;   *         stocks on particular dates.
&nbsp;   *
&nbsp;   * @throws IllegalArgumentException If any of the data returned from the DataIO object is null.
&nbsp;   */
<b class="fc">&nbsp;  public Model(DataIO dataIO, PriceProvider priceProvider) throws IllegalArgumentException {</b>
<b class="fc">&nbsp;    this.dataIO = dataIO;</b>
<b class="fc">&nbsp;    this.priceProvider = priceProvider;</b>
<b class="fc">&nbsp;    stockMasterList = dataIO.readMasterStockList();</b>
<b class="fc">&nbsp;    portfolioList = dataIO.readPersistedPortfolios();</b>
<b class="fc">&nbsp;    if (stockMasterList == null || portfolioList == null) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;List should not be null return an empty list instead&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    for(Portfolio portfolio: portfolioList){</b>
<b class="fc">&nbsp;      portfolio.executePendingTransactions(priceProvider);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  private static LocalDate lastDayOfQuarter(String quarterRepresentation) {
<b class="fc">&nbsp;    Map&lt;String, String&gt; quarterLastDayMap = Map.of(</b>
&nbsp;            &quot;Q1&quot;, &quot;03-31&quot;,
&nbsp;            &quot;Q2&quot;, &quot;06-30&quot;,
&nbsp;            &quot;Q3&quot;, &quot;09-30&quot;,
&nbsp;            &quot;Q4&quot;, &quot;12-31&quot;
&nbsp;    );
<b class="fc">&nbsp;    String[] splitOfQuarterRepresentation = quarterRepresentation.split(&quot;-&quot;);</b>
<b class="fc">&nbsp;    return LocalDate.parse(splitOfQuarterRepresentation[1] + &quot;-&quot;</b>
<b class="fc">&nbsp;            + quarterLastDayMap.get(splitOfQuarterRepresentation[0]));</b>
&nbsp;  }
&nbsp;
&nbsp;  private static List&lt;LocalDate&gt; getDatesToHitAPI(List&lt;String&gt; heading, Scales scale) {
<b class="fc">&nbsp;    switch (scale) {</b>
&nbsp;      case DAY:
<b class="fc">&nbsp;        return heading.stream().map(LocalDate::parse).collect(Collectors.toList());</b>
&nbsp;      case WEEK:
<b class="fc">&nbsp;        return heading.stream().map(o -&gt; o.substring(o.length() - 11).trim())</b>
<b class="fc">&nbsp;                .map(LocalDate::parse).collect(Collectors.toList());</b>
&nbsp;      case MONTH:
<b class="fc">&nbsp;        DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;dd MMM-uuuu&quot;);</b>
<b class="fc">&nbsp;        List&lt;LocalDate&gt; dates =</b>
<b class="fc">&nbsp;                heading.stream().map(o -&gt; LocalDate.parse(&quot;01 &quot; + o, format)</b>
<b class="fc">&nbsp;                                .with(lastDayOfMonth()))</b>
<b class="fc">&nbsp;                        .collect(Collectors.toList());</b>
<b class="fc">&nbsp;        return dates;</b>
&nbsp;      case QUARTER:
<b class="fc">&nbsp;        return heading.stream().map(o -&gt; lastDayOfQuarter(o)).collect(Collectors.toList());</b>
&nbsp;      case YEAR:
<b class="fc">&nbsp;        return heading.stream().map(o -&gt; LocalDate.parse(o + &quot;-12-31&quot;))</b>
<b class="fc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;      default:
<b class="nc">&nbsp;        return heading.stream().map(o -&gt; LocalDate.parse(o.split(&quot;-&quot;)[1] + &quot;-12-31&quot;))</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Predicate&lt;String&gt; isValidPortfolioName() {
<b class="fc">&nbsp;    return (s -&gt; Util.collectionToParallelStream(portfolioList)</b>
<b class="fc">&nbsp;            .filter(o -&gt; o.getPortfolioName().equalsIgnoreCase(s)).findAny().isPresent()</b>
<b class="fc">&nbsp;            || !s.matches(&quot;^\\w+( \\w+)*$&quot;));</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public Predicate&lt;String&gt; validateStockNameSymbol() {
<b class="fc">&nbsp;    return (s -&gt; getStockFromNameOrSymbol(s) == null);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public String loadFlexiblePortfolioFromFile(String portfolioName)
&nbsp;          throws IllegalArgumentException {
&nbsp;    // validation
<b class="fc">&nbsp;    if (isValidPortfolioName().test(portfolioName)) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Portfolio Name already Exists&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    //create a flexible portfolio and call the transact method for each entry in the file
<b class="fc">&nbsp;    List&lt;String&gt; fileContent = dataIO.readUserGivenFile(&quot;flexible&quot;);</b>
<b class="fc">&nbsp;    Portfolio newPortfolio = new FlexiblePortfolio(portfolioName, LocalDate.now(),</b>
&nbsp;            new ArrayList&lt;&gt;());
<b class="fc">&nbsp;    portfolioList.add(newPortfolio);</b>
<b class="fc">&nbsp;    int portfolioNumber = portfolioList.indexOf(newPortfolio);</b>
&nbsp;    try {
<b class="fc">&nbsp;      for (String stock : fileContent) {</b>
<b class="fc">&nbsp;        String[] arr = stock.split(Util.FILE_SEPARATOR);</b>
<b class="fc">&nbsp;        transactStock(portfolioNumber + 1, arr[0], Double.parseDouble(arr[1]),</b>
<b class="fc">&nbsp;                arr[3], Util.getDateFromString(arr[2]));</b>
<b class="fc">&nbsp;      }</b>
<b class="nc">&nbsp;    } catch (Exception e) {</b>
<b class="nc">&nbsp;      portfolioList.remove(portfolioNumber);</b>
<b class="nc">&nbsp;      throw new RuntimeException(&quot;Unable to load the portfolio,Please verify the file data\n&quot;</b>
<b class="nc">&nbsp;              + e.getMessage());</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return &quot;Successfully created the portfolio&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String loadInFlexiblePortfolioFromFile(String portfolioName)
&nbsp;          throws IllegalArgumentException {
&nbsp;    // validation
<b class="fc">&nbsp;    if (isValidPortfolioName().test(portfolioName)) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Portfolio Name already Exists&quot;);</b>
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    List&lt;String&gt; fileContent = dataIO.readUserGivenFile(&quot;inflexible&quot;);</b>
&nbsp;    try {
<b class="fc">&nbsp;      createInflexiblePortfolio(portfolioName, fileContent);</b>
<b class="fc">&nbsp;    } catch (Exception e) {</b>
<b class="fc">&nbsp;      throw new RuntimeException(&quot;Unable to load the portfolio,Please verify the file data\n&quot;</b>
<b class="fc">&nbsp;              + e.getMessage());</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    return &quot;Successfully created the portfolio&quot;;</b>
&nbsp;  }
&nbsp;
&nbsp;  private Stock getStockFromNameOrSymbol(String stockSymbol) {
<b class="fc">&nbsp;    return Util.collectionToParallelStream(stockMasterList)</b>
<b class="fc">&nbsp;            .filter(o -&gt; o.getStockSymbol().equalsIgnoreCase(stockSymbol)</b>
<b class="fc">&nbsp;                    || o.getStockName().equalsIgnoreCase(stockSymbol)).findAny().orElse(null);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public List&lt;String&gt; getPortfolioComposition(int index, LocalDate date)
&nbsp;          throws IllegalArgumentException {
<b class="fc">&nbsp;    if (index &lt; 1 || index &gt; portfolioList.size()) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid portfolio Index provided&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    return portfolioList.get(index - 1).getPortfolioComposition(date);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public void transactStock(int portfolioIndex, String stockSymbol, Double stockQty,
&nbsp;          String transactionType, LocalDate transactionDate)
&nbsp;          throws RuntimeException {
&nbsp;    //validate input args
<b class="fc">&nbsp;    if ((portfolioIndex &lt; 1 || portfolioIndex &gt; portfolioList.size())</b>
<b class="fc">&nbsp;            || validateStockNameSymbol().test(stockSymbol) || stockQty &lt; 1 || (!transactionType</b>
<b class="fc">&nbsp;            .equalsIgnoreCase(&quot;b&quot;) &amp;&amp; !transactionType</b>
<b class="fc">&nbsp;            .equalsIgnoreCase(&quot;s&quot;)) || transactionDate.isAfter(LocalDate.now())) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid Arguments,Please verify the input arguments&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // if args are valid proceed with transaction
<b class="fc">&nbsp;    Stock stock = getStockFromNameOrSymbol(stockSymbol);</b>
<b class="fc">&nbsp;    Util.TransactionType transactionTypeEnum = transactionType.equalsIgnoreCase(&quot;b&quot;)</b>
<b class="fc">&nbsp;            ? transactionTypes.BUY : transactionTypes.SELL;</b>
<b class="fc">&nbsp;    Portfolio portfolio = portfolioList.get(portfolioIndex - 1);</b>
&nbsp;
<b class="fc">&nbsp;    Portfolio editedPortfolio = portfolio.transactStock(stock.getStockSymbol(),</b>
<b class="fc">&nbsp;            stock.getStockName(),</b>
&nbsp;            stockQty, transactionTypeEnum,
&nbsp;            transactionDate, commission);
<b class="fc">&nbsp;    portfolioList.set(portfolioIndex - 1, editedPortfolio);</b>
&nbsp;    try {
<b class="fc">&nbsp;      dataIO.savePortfolios(portfolioList);</b>
<b class="nc">&nbsp;    } catch (IOException e) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(&quot;Unable to save the portfolio changes\n&quot; + e.getMessage());</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public void setCommission(Double commission) throws IllegalArgumentException {
<b class="fc">&nbsp;    if (commission &lt; 0) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid commission value, it cannot be negative&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    this.commission = commission;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public double getCostBasis(int portfolioIndex, LocalDate date) throws RuntimeException {
<b class="fc">&nbsp;    if ((portfolioIndex &lt; 1 || portfolioIndex &gt; portfolioList.size())</b>
<b class="fc">&nbsp;            || date.isAfter(LocalDate.now())) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid arguments provided to the method&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    Portfolio portfolio = portfolioList.get(portfolioIndex - 1);</b>
<b class="fc">&nbsp;    return portfolio.getCostBasis(date, priceProvider);</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public String executeStrategy(int portfolioIndex, List&lt;String&gt; stockAndWeights,
&nbsp;          Double investmentAmount, LocalDate startDate, LocalDate endDate, Double commission,
&nbsp;          int frequency) throws RuntimeException {
<b class="fc">&nbsp;    String response = &quot;&quot;;</b>
&nbsp;    // Args validations
&nbsp;    // portfolio Index
<b class="fc">&nbsp;    if ((portfolioIndex &lt; 1 || portfolioIndex &gt; portfolioList.size())) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid portfolio Index&quot;);</b>
&nbsp;    }
&nbsp;    //stock Symbols
<b class="fc">&nbsp;    if (stockAndWeights.parallelStream().anyMatch(stock -&gt;</b>
<b class="fc">&nbsp;            validateStockNameSymbol().test(stock.split(Util.FILE_SEPARATOR)[0]))) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid Stock Name or Symbol&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // weights
&nbsp;    try {
<b class="fc">&nbsp;      List&lt;Double&gt; weights = stockAndWeights.stream().map(s -&gt; Double.parseDouble</b>
<b class="fc">&nbsp;              (s.split(Util.FILE_SEPARATOR)[1])).collect(Collectors.toList());</b>
<b class="fc">&nbsp;      if (weights.parallelStream().anyMatch(w -&gt; w &lt; 0)) {</b>
<b class="fc">&nbsp;        throw new IllegalArgumentException(&quot;weight cannot be negative&quot;);</b>
&nbsp;      }
<b class="fc">&nbsp;      Double addedWeights = weights.stream().reduce(0d, (a, b) -&gt; a + b);</b>
<b class="fc">&nbsp;      if (addedWeights != 100d) {</b>
<b class="fc">&nbsp;        throw new IllegalArgumentException(&quot;Addition of weights must be 100&quot;);</b>
&nbsp;      }
<b class="fc">&nbsp;    } catch (NumberFormatException e) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Invalid weight passed, please pass a valid float number&quot;);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;
&nbsp;    //investment amount
<b class="fc">&nbsp;    if (investmentAmount &lt;= 0) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Please enter a valid positive Investment amount&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    if (investmentAmount &lt; stockAndWeights.size() * commission) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;The total commission for doing the above transactions &quot;</b>
<b class="fc">&nbsp;              + &quot;would be &quot; + stockAndWeights.size() * commission + &quot; please enter an investment &quot;</b>
&nbsp;              + &quot;amount greater than the total commissions&quot;);
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    if (startDate == null || endDate == null) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Start date cannot be null,please enter a valid date&quot;);</b>
&nbsp;    }
&nbsp;    // startDate
<b class="fc">&nbsp;    if(startDate.isAfter(endDate)){</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Start date cannot be greater than endDate&quot;);</b>
&nbsp;    }
&nbsp;    //commission
<b class="fc">&nbsp;    if (commission &lt; 0) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Commission cannot be negative&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    //frequency
<b class="fc">&nbsp;    if (frequency &lt; 0) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Please enter a valid positive frequency&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    // call the execute function once all validations are passed
<b class="fc">&nbsp;    Portfolio portfolio = portfolioList.get(portfolioIndex - 1);</b>
<b class="fc">&nbsp;    List&lt;StockWeight&gt; stockWeights = stockAndWeights.stream().map(s -&gt; {</b>
<b class="fc">&nbsp;      String[] arr = s.split(Util.FILE_SEPARATOR);</b>
<b class="fc">&nbsp;      Stock stockObj = getStockFromNameOrSymbol(arr[0]);</b>
<b class="fc">&nbsp;      return new StockWeight(stockObj.getStockSymbol(), stockObj.getStockName(),</b>
<b class="fc">&nbsp;              Double.parseDouble(arr[1]));</b>
<b class="fc">&nbsp;    }).collect(Collectors.toList());</b>
<b class="fc">&nbsp;    Strategy strategy = new Strategy(startDate, endDate, null, investmentAmount, commission,</b>
<b class="fc">&nbsp;            frequency, stockWeights);</b>
&nbsp;
<b class="fc">&nbsp;    for (LocalDate date = startDate; date.isBefore(endDate.plusDays(1)); date =</b>
<b class="fc">&nbsp;            date.plusDays(frequency)) {</b>
&nbsp;      try {
<b class="fc">&nbsp;        portfolio.executeStrategy(stockWeights, investmentAmount, date, commission, priceProvider);</b>
<b class="fc">&nbsp;        strategy.setDateUntilCalculated(date);</b>
<b class="fc">&nbsp;        response = (DAYS.between(strategy.getStartDate(), strategy.getEndDate()) &gt; 1)?</b>
<b class="fc">&nbsp;                &quot;Strategy successfully executed till &quot; + date : &quot;Strategy successfully executed &quot;</b>
<b class="fc">&nbsp;                + &quot;for date &quot;+ date;</b>
<b class="fc">&nbsp;      } catch (RuntimeException e) {</b>
<b class="fc">&nbsp;        if (response.equals(&quot;&quot;)) {</b>
<b class="fc">&nbsp;          if (DAYS.between(strategy.getStartDate(), strategy.getEndDate()) &gt; 1) {</b>
<b class="fc">&nbsp;            response = &quot;No transactions were executed,your strategy is saved and will be executed&quot;</b>
&nbsp;                    + &quot; when the appropriate day arrives.&quot;;
&nbsp;          } else {
<b class="fc">&nbsp;            response = &quot;Failed to execute the strategy&quot;;</b>
&nbsp;
&nbsp;          }
&nbsp;        }
<b class="fc">&nbsp;        break;</b>
<b class="fc">&nbsp;      }</b>
&nbsp;    }
&nbsp;    // save strategy if recurring
<b class="fc">&nbsp;    if (DAYS.between(strategy.getStartDate(), strategy.getEndDate()) &gt; 1) {</b>
<b class="fc">&nbsp;      portfolio.getStrategies().add(strategy);</b>
&nbsp;      try {
<b class="fc">&nbsp;        dataIO.savePortfolios(portfolioList);</b>
<b class="nc">&nbsp;      } catch (IOException e) {</b>
<b class="nc">&nbsp;        throw new RuntimeException(e);</b>
<b class="fc">&nbsp;      }</b>
&nbsp;    }
<b class="fc">&nbsp;    return response;</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public void createInflexiblePortfolio(String portfolioName, List&lt;String&gt; stocks)
&nbsp;          throws RuntimeException {
&nbsp;    //validate incoming args
<b class="fc">&nbsp;    boolean isInValid = stocks.parallelStream().anyMatch(stock -&gt; {</b>
<b class="fc">&nbsp;      String[] arr = stock.split(Util.FILE_SEPARATOR);</b>
<b class="fc">&nbsp;      String name = arr[0];</b>
<b class="fc">&nbsp;      Double stockQty = Double.parseDouble(arr[1]);</b>
<b class="fc">&nbsp;      LocalDate dateOfTransaction = Util.getDateFromString(arr[2]);</b>
<b class="fc">&nbsp;      return validateStockNameSymbol().test(name) || isValidPortfolioName().test(portfolioName)</b>
<b class="fc">&nbsp;              || stockQty &lt; 0 || dateOfTransaction.isAfter(LocalDate.now());</b>
&nbsp;    });
<b class="fc">&nbsp;    if (isInValid) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Please verify the input arguments&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    //if valid proceed with the creation
<b class="fc">&nbsp;    List&lt;PurchasedStock&gt; purchasedStockList = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;    for (String stockString : stocks) {</b>
<b class="fc">&nbsp;      String[] stockValues = stockString.split(Util.FILE_SEPARATOR);</b>
<b class="fc">&nbsp;      LocalDate dateOfTransaction = Util.getDateFromString(stockValues[2]);</b>
<b class="fc">&nbsp;      Double stockQty = Double.parseDouble(stockValues[1]);</b>
<b class="fc">&nbsp;      Stock stockObj = getStockFromNameOrSymbol(stockValues[0]);</b>
&nbsp;
<b class="fc">&nbsp;      PurchasedStock existingStock = purchasedStockList.parallelStream().filter((o -&gt;</b>
<b class="fc">&nbsp;                      stockObj.getStockSymbol().equalsIgnoreCase(</b>
<b class="fc">&nbsp;                              o.getStockSymbol()))).findAny()</b>
<b class="fc">&nbsp;              .orElse(null);</b>
&nbsp;
&nbsp;      //if stock already exists edit the same stock
<b class="fc">&nbsp;      if (existingStock != null) {</b>
<b class="fc">&nbsp;        StockTransaction floorTransaction = existingStock.getStockTransactions().</b>
<b class="fc">&nbsp;                floor(new StockTransaction(</b>
&nbsp;                        dateOfTransaction));
<b class="fc">&nbsp;        Double previousCumulativeQty = floorTransaction == null ? 0</b>
<b class="fc">&nbsp;                : floorTransaction.getQuantityAfterTransaction();</b>
<b class="fc">&nbsp;        boolean isDifferentDate =</b>
<b class="fc">&nbsp;                existingStock.getStockTransactions().add(new StockTransaction(dateOfTransaction,</b>
<b class="fc">&nbsp;                        previousCumulativeQty</b>
<b class="fc">&nbsp;                                + stockQty,</b>
&nbsp;                        commission,
&nbsp;                        transactionTypes.BUY));
<b class="fc">&nbsp;        if (!isDifferentDate) {</b>
<b class="fc">&nbsp;          floorTransaction.setQuantityAfterTransaction(previousCumulativeQty + stockQty);</b>
&nbsp;        }
<b class="fc">&nbsp;      } else {</b>
&nbsp;        // if not exists create a new stock and add to the list
<b class="fc">&nbsp;        purchasedStockList.add(new PurchasedStock(stockObj.getStockName(),</b>
<b class="fc">&nbsp;                stockObj.getStockSymbol(),</b>
<b class="fc">&nbsp;                new TreeSet&lt;&gt;(List.of(new StockTransaction(</b>
&nbsp;                        dateOfTransaction, stockQty, commission,
&nbsp;                        transactionTypes.BUY)))));
&nbsp;      }
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;    InFlexiblePortfolio inFlexiblePortfolio = new InFlexiblePortfolio(portfolioName,</b>
<b class="fc">&nbsp;            LocalDate.now(),</b>
&nbsp;            purchasedStockList);
<b class="fc">&nbsp;    portfolioList.add(inFlexiblePortfolio);</b>
&nbsp;    try {
<b class="fc">&nbsp;      dataIO.savePortfolios(portfolioList);</b>
<b class="nc">&nbsp;    } catch (IOException e) {</b>
<b class="nc">&nbsp;      throw new RuntimeException(&quot;Unable to save portfolio&quot;);</b>
<b class="fc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  @Override
&nbsp;  public int createFlexiblePortfolio(String portfolioName) throws IllegalArgumentException {
<b class="fc">&nbsp;    if (isValidPortfolioName().test(portfolioName)) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;Portfolio name already exists&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    Portfolio newPortfolio = new FlexiblePortfolio(portfolioName, LocalDate.now(),</b>
&nbsp;            new ArrayList&lt;&gt;());
<b class="fc">&nbsp;    portfolioList.add(newPortfolio);</b>
<b class="fc">&nbsp;    return portfolioList.indexOf(newPortfolio) + 1;</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public StockPriceResponseWrapper getPortfolioValueOnDate(int portfolioIndex, LocalDate date)
&nbsp;          throws IllegalArgumentException {
<b class="fc">&nbsp;    if (portfolioIndex &lt; 1 || portfolioIndex &gt; portfolioList.size()) {</b>
<b class="fc">&nbsp;      throw new IllegalArgumentException(&quot;invalid portfolio index&quot;);</b>
&nbsp;    }
<b class="fc">&nbsp;    return portfolioList.get(portfolioIndex - 1).getPortfolioValueOnDate(date, priceProvider);</b>
&nbsp;  }
&nbsp;
&nbsp;
&nbsp;  @Override
&nbsp;  public List&lt;String&gt; getAllPortfolios() {
<b class="fc">&nbsp;    List&lt;String&gt; portfolioNames =</b>
<b class="fc">&nbsp;            portfolioList.stream().map(p -&gt; p.getPortfolioName() + Util.FILE_OUTPUT_SEPARATOR</b>
<b class="fc">&nbsp;                    + p.getDateAdded().toString() + Util.FILE_OUTPUT_SEPARATOR</b>
<b class="fc">&nbsp;                    + p.getStocks().size()).collect(Collectors.toList());</b>
<b class="fc">&nbsp;    return portfolioNames;</b>
&nbsp;  }
&nbsp;
&nbsp;  private String getScaledFormat(LocalDate currentDate, Scales scale) {
&nbsp;
<b class="fc">&nbsp;    switch (scale) {</b>
&nbsp;      case DAY:
<b class="fc">&nbsp;        return currentDate.toString();</b>
&nbsp;      case WEEK:
<b class="fc">&nbsp;        String startOfWeek =</b>
<b class="fc">&nbsp;                currentDate.with(TemporalAdjusters.previousOrSame(this.firstDayOfWeek)).toString();</b>
<b class="fc">&nbsp;        String endOfWeek =</b>
<b class="fc">&nbsp;                currentDate.with(TemporalAdjusters.nextOrSame(this.lastDayOfWeek)).toString();</b>
<b class="fc">&nbsp;        return String.format(&quot;Week: %s to %s &quot;, startOfWeek, endOfWeek);</b>
&nbsp;      case MONTH:
<b class="fc">&nbsp;        return currentDate.format(DateTimeFormatter.ofPattern(&quot;MMM-uuuu&quot;, Locale.ENGLISH));</b>
&nbsp;      case QUARTER:
<b class="fc">&nbsp;        return currentDate.format(DateTimeFormatter.ofPattern(&quot;QQQ-uuuu&quot;, Locale.ENGLISH));</b>
&nbsp;      case YEAR:
<b class="fc">&nbsp;        return &quot;&quot; + currentDate.getYear();</b>
&nbsp;      case LEAP_YEAR:
<b class="nc">&nbsp;        while (!currentDate.isLeapYear()) {</b>
<b class="nc">&nbsp;          currentDate = currentDate.minusYears(1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot; + currentDate.getYear() + &quot;-&quot; + currentDate.plusYears(3).getYear();</b>
&nbsp;      case DECADE:
<b class="nc">&nbsp;        while (currentDate.getYear() % 10 != 0) {</b>
<b class="nc">&nbsp;          currentDate = currentDate.minusYears(1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot; + currentDate.getYear() + &quot;-&quot; + currentDate.plusYears(9).getYear();</b>
&nbsp;      case SEMI_CENTENNIAL:
<b class="nc">&nbsp;        while (currentDate.getYear() % 50 != 0) {</b>
<b class="nc">&nbsp;          currentDate = currentDate.minusYears(1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot; + currentDate.getYear() + &quot;-&quot; + currentDate.plusYears(49).getYear();</b>
&nbsp;      case CENTURY:
<b class="nc">&nbsp;        while (currentDate.getYear() % 100 != 0) {</b>
<b class="nc">&nbsp;          currentDate = currentDate.minusYears(1);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot; + currentDate.getYear() + &quot;-&quot; + currentDate.plusYears(99).getYear();</b>
&nbsp;      default:
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  private Float findTotalPriceOfPortfolioOnDate(List&lt;String&gt; successList) {
<b class="fc">&nbsp;    float totalPrice = 0;</b>
<b class="fc">&nbsp;    for (int i = 0; i &lt; successList.size(); i++) {</b>
<b class="fc">&nbsp;      totalPrice += Float.parseFloat(successList.get(i).split(&quot;\\|&quot;)[4]);</b>
&nbsp;    }
<b class="fc">&nbsp;    return Float.valueOf(totalPrice);</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * This method fetches the graph date for given interval of date and formats the data in order for
&nbsp;   * the view to display it.
&nbsp;   *
&nbsp;   * @param portfolioNumber The portfolio number from the list
&nbsp;   * @param startDate The start date of the scale on which needs to be shown
&nbsp;   * @param endDate The end date of the scale which needs to be shown.
&nbsp;   *
&nbsp;   * @return List of strings of the data with scale, price and normalized price.
&nbsp;   */
&nbsp;  @Override
&nbsp;  public List&lt;String&gt; fetchGraphData(int portfolioNumber, LocalDate startDate,
&nbsp;          LocalDate endDate) {
<b class="fc">&nbsp;    Portfolio portfolio = portfolioList.get(portfolioNumber - 1);</b>
&nbsp;
<b class="fc">&nbsp;    long daysBetween = DAYS.between(startDate, endDate);</b>
<b class="fc">&nbsp;    List&lt;LocalDate&gt; datesList =</b>
<b class="fc">&nbsp;            Stream.iterate(startDate, date -&gt; date.plusDays(1)).limit(daysBetween + 1)</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    Map&lt;String, List&lt;LocalDate&gt;&gt; result_map = new TreeMap&lt;&gt;();</b>
<b class="fc">&nbsp;    Scales scaleDecided = null;</b>
<b class="fc">&nbsp;    for (Scales scale : Scales.values()) {</b>
<b class="fc">&nbsp;      if (Period.between(startDate, endDate).getYears() &gt; 10) {</b>
<b class="nc">&nbsp;        if (scale.equals(Scales.DAY) || scale.equals(Scales.WEEK)</b>
<b class="nc">&nbsp;                || scale.equals(Scales.MONTH) || scale.equals(Scales.QUARTER)) {</b>
<b class="nc">&nbsp;          continue;</b>
&nbsp;        }
&nbsp;      }
<b class="fc">&nbsp;      result_map =</b>
<b class="fc">&nbsp;              datesList.stream().collect(Collectors.groupingBy(item -&gt; getScaledFormat(item, scale),</b>
&nbsp;                      LinkedHashMap::new,
<b class="fc">&nbsp;                      Collectors.toList()));</b>
<b class="fc">&nbsp;      int minFactor = 5;</b>
<b class="fc">&nbsp;      if (scale.equals(Scales.DAY)) {</b>
<b class="fc">&nbsp;        minFactor = 0;</b>
&nbsp;      }
<b class="fc">&nbsp;      if (result_map.size() &gt;= minFactor &amp;&amp; result_map.size() &lt; 31) {</b>
<b class="fc">&nbsp;        scaleDecided = scale;</b>
<b class="fc">&nbsp;        break;</b>
&nbsp;      }
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    List&lt;String&gt; dateScales = new ArrayList&lt;&gt;(result_map.keySet());</b>
<b class="fc">&nbsp;    List&lt;LocalDate&gt; dates = getDatesToHitAPI(dateScales, scaleDecided);</b>
<b class="fc">&nbsp;    dates.remove(dates.size() - 1);</b>
<b class="fc">&nbsp;    dates.add(endDate);</b>
<b class="fc">&nbsp;    List&lt;StockPriceResponseWrapper&gt; responses =</b>
<b class="fc">&nbsp;            dates.stream().map(o -&gt; portfolio.getPortfolioValueOnDate(o, this.priceProvider))</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList());</b>
&nbsp;
<b class="fc">&nbsp;    List&lt;Float&gt; prices =</b>
<b class="fc">&nbsp;            responses.stream().map(o -&gt; findTotalPriceOfPortfolioOnDate(o.getSuccessList()))</b>
<b class="fc">&nbsp;                    .collect(Collectors.toList());</b>
<b class="fc">&nbsp;    Float max = Collections.max(prices);</b>
<b class="fc">&nbsp;    List&lt;String&gt; graphOutput = IntStream.range(0, prices.size())</b>
<b class="fc">&nbsp;            .mapToObj(i -&gt; new GraphResponseWrapper(dateScales.get(i),</b>
<b class="fc">&nbsp;                    prices.get(i)))</b>
<b class="fc">&nbsp;            .map(o -&gt; o.getString(max))</b>
<b class="fc">&nbsp;            .collect(Collectors.toList());</b>
<b class="fc">&nbsp;    return graphOutput;</b>
&nbsp;
&nbsp;  }
&nbsp;
<b class="fc">&nbsp;  private enum Scales {</b>
<b class="fc">&nbsp;    DAY, WEEK, MONTH, QUARTER, YEAR, LEAP_YEAR, DECADE, SEMI_CENTENNIAL, CENTURY;</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2022-11-27 17:21</div>
</div>
</body>
</html>
